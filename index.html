<!DOCTYPE html>
<html>
<head>
    <title>Big Box Game</title>
    <style>
        body { margin: 0; background: #222; }
        #three-canvas { display: block; margin: 0 auto; background: #222; }
        #instructions {
            color: #fff;
            text-align: center;
            font-family: Arial, sans-serif;
            margin-top: 20px;
        }
    </style>
</head>
<body>
  <div id="instructions">
    <h2>Big Box Game</h2>
    <p>Use W/A/S/D to walk, Space to jump.<br>Click the canvas to look around.<br>The camera follows the player.</p>
  </div>
    <canvas id="three-canvas"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
    // Simple 3D game: player in a big box, walk, jump, camera follows, portals
    const canvas = document.getElementById('three-canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.8;
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(canvas.width, canvas.height);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#222');

    const camera = new THREE.PerspectiveCamera(75, canvas.width/canvas.height, 0.1, 1000);

    // Big box (walls, floor, ceiling)
    const boxSize = 40;
    // Lighting
    const light = new THREE.DirectionalLight(0xffffff, 0.5);
    light.position.set(20, 40, 20);
    scene.add(light);
    // Soft point light in the center
    const centerLight = new THREE.PointLight(0xfff8e1, 0.8, 60);
    centerLight.position.set(boxSize/2, boxSize/2, boxSize/2);
    scene.add(centerLight);

    const wallMat = new THREE.MeshLambertMaterial({ color: 0x444444, side: THREE.BackSide });
    const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
    const boxMesh = new THREE.Mesh(boxGeo, wallMat);
    boxMesh.position.set(boxSize/2, boxSize/2, boxSize/2);
    scene.add(boxMesh);

    // Portalable walls (thin panels inside the box)
    const portalableWalls = [];
    function addPortalableWall(x, y, z, rotY=0, rotX=0) {
      const wallGeo = new THREE.BoxGeometry(10, 10, 0.5);
      const wallMat = new THREE.MeshLambertMaterial({ color: 0x90caf9 });
      const wall = new THREE.Mesh(wallGeo, wallMat);
      wall.position.set(x, y, z);
      wall.rotation.y = rotY;
      wall.rotation.x = rotX;
      scene.add(wall);
      portalableWalls.push(wall);
    }
    addPortalableWall(boxSize/2, 5, 5); // front
    addPortalableWall(boxSize/2, 5, boxSize-5); // back
    addPortalableWall(5, 5, boxSize/2, Math.PI/2); // left
    addPortalableWall(boxSize-5, 5, boxSize/2, Math.PI/2); // right
    addPortalableWall(boxSize/2, 15, boxSize/2); // center
    // Portalable ceiling and floor
    function addPortalableFloorCeiling(y) {
      const geo = new THREE.BoxGeometry(10, 0.5, 10);
      const mat = new THREE.MeshLambertMaterial({ color: 0x90caf9 });
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const panel = new THREE.Mesh(geo, mat);
          panel.position.set(10 + i*10, y, 10 + j*10);
          scene.add(panel);
          portalableWalls.push(panel);
        }
      }
    }
    addPortalableFloorCeiling(1); // floor
    addPortalableFloorCeiling(boxSize-1); // ceiling

    // Player
    const playerSize = 2;
    const playerGeo = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
    const playerMat = new THREE.MeshLambertMaterial({ color: 0xff3333 });
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.position.set(boxSize/2, playerSize/2, boxSize/2);
    scene.add(player);

  // Portals
  let portal1 = null, portal2 = null;
  let portal1Pos = null, portal2Pos = null;
  let portal1Normal = null, portal2Normal = null;
  const portalGeo = new THREE.CylinderGeometry(1, 1, 0.2, 32);
  // Render targets for portal views
  const portalRT1 = new THREE.WebGLRenderTarget(128, 128);
  const portalRT2 = new THREE.WebGLRenderTarget(128, 128);
  const portalMat1 = new THREE.MeshBasicMaterial({ map: portalRT2.texture });
  const portalMat2 = new THREE.MeshBasicMaterial({ map: portalRT1.texture });

    // Controls
    const keys = {};
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // Mouse look
    let yaw = 0, pitch = 0;
    let isPointerLocked = false;
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
    canvas.onclick = () => canvas.requestPointerLock();
    document.addEventListener('pointerlockchange', lockChange, false);
    document.addEventListener('mozpointerlockchange', lockChange, false);
    function lockChange() {
      isPointerLocked = document.pointerLockElement === canvas || document.mozPointerLockElement === canvas;
    }
    document.addEventListener('mousemove', function(e) {
      if (!isPointerLocked) return;
      yaw -= e.movementX * 0.002;
      pitch -= e.movementY * 0.002;
  pitch = Math.max(-Math.PI*0.95, Math.min(Math.PI*0.95, pitch));
    });

    // Jump logic
    let velocityY = 0;
    let isOnGround = true;

    // Portal gun: shoot portals with left/right click
    canvas.addEventListener('mousedown', function(e) {
      if (!isPointerLocked) return;
      if (e.button !== 0 && e.button !== 2) return;
      // Shoot ray from player in look direction
      const lookDir = new THREE.Vector3(Math.sin(yaw), Math.sin(pitch), Math.cos(yaw)).normalize();
      const raycaster = new THREE.Raycaster(player.position.clone().add(new THREE.Vector3(0, playerSize/2, 0)), lookDir);
      const intersects = raycaster.intersectObjects(portalableWalls);
      if (intersects.length > 0) {
        const hit = intersects[0];
        const hitPos = hit.point;
        const hitNormal = hit.face.normal.clone();
        // Place portal at hitPos, oriented to hitNormal
        function orientPortal(portal, normal) {
          // Default portal faces +Z, so align +Z to normal
          const portalForward = new THREE.Vector3(0, 0, 1);
          const targetNormal = normal.clone().normalize();
          if (Math.abs(targetNormal.y) > 0.9) {
            // Floor or ceiling: align +Y to normal
            const portalUp = new THREE.Vector3(0, 1, 0);
            portal.quaternion.setFromUnitVectors(portalUp, targetNormal);
          } else {
            // Wall: align portal so +Z is flush with wall normal, +Y is up
            const wallNormal = targetNormal;
            // Project world up onto the wall to get the best up direction
            let up = new THREE.Vector3(0, 1, 0);
            // If wall is vertical, projected up is world up
            if (Math.abs(wallNormal.y) < 0.01) {
              up = new THREE.Vector3(0, 1, 0);
            } else {
              // Otherwise, project world up onto the wall
              up = up.sub(wallNormal.clone().multiplyScalar(up.dot(wallNormal))).normalize();
            }
            // Right vector
            const right = up.clone().cross(wallNormal).normalize();
            // Build rotation matrix
            const m = new THREE.Matrix4();
            m.makeBasis(right, up, wallNormal);
            portal.setRotationFromMatrix(m);
          }
        }
        if (e.button === 0) { // left click: portal 1
          if (portal1) scene.remove(portal1);
          portal1Pos = hitPos;
          portal1Normal = hitNormal;
          portal1 = new THREE.Mesh(portalGeo, portalMat1);
          portal1.position.copy(portal1Pos);
          orientPortal(portal1, hitNormal);
          scene.add(portal1);
        } else if (e.button === 2) { // right click: portal 2
          if (portal2) scene.remove(portal2);
          portal2Pos = hitPos;
          portal2Normal = hitNormal;
          portal2 = new THREE.Mesh(portalGeo, portalMat2);
          portal2.position.copy(portal2Pos);
          orientPortal(portal2, hitNormal);
          scene.add(portal2);
        }
      }
    });

    function updateCamera() {
      // Camera follows player and looks where mouse points
      const camDist = 8;
      const camHeight = 4;
      const lookDir = new THREE.Vector3(Math.sin(yaw), Math.sin(pitch), Math.cos(yaw)).normalize();
      camera.position.x = player.position.x - lookDir.x * camDist;
      camera.position.y = player.position.y + camHeight - lookDir.y * camDist;
      camera.position.z = player.position.z - lookDir.z * camDist;
      camera.lookAt(player.position.x + lookDir.x * 2, player.position.y + lookDir.y * 2, player.position.z + lookDir.z * 2);
    }

    let portalCooldown = 0;
    function checkPortalTeleport() {
      if (portalCooldown > 0) {
        portalCooldown--;
        return;
      }
      if (portal1 && portal2 && portal1Pos && portal2Pos) {
        // Helper to teleport and match orientation
        function teleportPlayer(srcPortal, dstPortal, dstNormal) {
          // Move player to the center of destination portal, offset in normal direction
          const offset = dstNormal.clone().multiplyScalar(1.2);
          player.position.copy(dstPortal.position).add(offset);
          // Transform facing direction (yaw/pitch) to match portal orientation
          // Get src and dst portal normals
          const srcNormal = srcPortal === portal1 ? portal1Normal : portal2Normal;
          // Calculate new yaw/pitch based on normal
          // For simplicity, set yaw to match dstNormal's horizontal angle
          yaw = Math.atan2(dstNormal.x, dstNormal.z);
          // For vertical portals, adjust pitch
          if (Math.abs(dstNormal.y) > 0.9) {
            pitch = dstNormal.y > 0 ? -Math.PI/2 : Math.PI/2;
          } else {
            pitch = 0;
          }
          // Optionally, transform velocity direction (if jumping through)
          // Not implemented: advanced velocity transform
          portalCooldown = 30; // ~0.5s cooldown
        }
        // If player is close to portal1, teleport to portal2
        if (player.position.distanceTo(portal1.position) < 2) {
          teleportPlayer(portal1, portal2, portal2Normal);
        }
        // If player is close to portal2, teleport to portal1
        if (player.position.distanceTo(portal2.position) < 2) {
          teleportPlayer(portal2, portal1, portal1Normal);
        }
      }
    }

    function renderPortalView(portalFrom, portalTo, renderTarget) {
      if (!portalFrom || !portalTo) return;
      // Hide the portal being rendered to avoid recursive view
      portalFrom.visible = false;
      // Set up a virtual camera at portalTo, looking out
      const portalCam = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      portalCam.position.copy(portalTo.position);
      // Look in the same direction as portalFrom
      portalCam.rotation.copy(portalFrom.rotation);
      portalCam.updateMatrixWorld();
      renderer.setRenderTarget(renderTarget);
      renderer.render(scene, portalCam);
      renderer.setRenderTarget(null);
      portalFrom.visible = true;
    }

    function animate() {
      // Player movement
      const moveSpeed = 0.2 * playerSize;
      if (keys['w']) {
        player.position.x += Math.sin(yaw) * moveSpeed;
        player.position.z += Math.cos(yaw) * moveSpeed;
      }
      if (keys['s']) {
        player.position.x -= Math.sin(yaw) * moveSpeed;
        player.position.z -= Math.cos(yaw) * moveSpeed;
      }
      if (keys['a']) {
        player.position.x += Math.sin(yaw + Math.PI/2) * moveSpeed;
        player.position.z += Math.cos(yaw + Math.PI/2) * moveSpeed;
      }
      if (keys['d']) {
        player.position.x += Math.sin(yaw - Math.PI/2) * moveSpeed;
        player.position.z += Math.cos(yaw - Math.PI/2) * moveSpeed;
      }
      // Jump
      if (keys[' ']) {
        if (isOnGround) {
          velocityY = 0.25 * playerSize;
          isOnGround = false;
        }
      }
      // Gravity
      velocityY -= 0.01 * playerSize;
      player.position.y += velocityY;
      // Floor collision
      if (player.position.y <= playerSize/2) {
        player.position.y = playerSize/2;
        velocityY = 0;
        isOnGround = true;
      }
      // Ceiling collision
      if (player.position.y >= boxSize - playerSize/2) {
        player.position.y = boxSize - playerSize/2;
        velocityY = 0;
      }
      // Wall collision
      player.position.x = Math.max(playerSize/2, Math.min(player.position.x, boxSize - playerSize/2));
      player.position.z = Math.max(playerSize/2, Math.min(player.position.z, boxSize - playerSize/2));
      checkPortalTeleport();
      // Render portal views
      renderPortalView(portal1, portal2, portalRT1);
      renderPortalView(portal2, portal1, portalRT2);
      updateCamera();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
    </script>
</body>
</html>
